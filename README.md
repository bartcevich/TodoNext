## Getting Started

First, run the development server:

```bash
npm install  Установите зависимости
npm run dev запустить приложение в режиме разработки
npm run build создать производство-сборку
```
 тестовые учетные данные test@example.com / password123
В приложении для управления задачами используются следующие паттерны проектирования с обоснованием их применения:

---

1. Provider Pattern
   Где используется:
   • Redux Provider (<Provider store={store}> в корневом компоненте)
   • Next.js Context (если используется ThemeProvider или другие провайдеры)
   Обоснование:
   • Централизованное управление состоянием (Redux)
   • Избегание пропс-дриллинга для глобальных данных (тема, аутентификация)

---

2. Custom Hooks
   Где используется:
   • useTasks, useTaskLists (в features/task-management/api.ts)
   Пример:
   ts
   export const useTasks = (listId: string) => {
   const dispatch = useDispatch();
   const tasks = useSelector(/_..._/);
   // Логика работы с задачами
   return { tasks, addTask };
   };
   Обоснование:
   • Инкапсуляция сложной логики работы с Redux
   • Повторное использование кода между компонентами

---

3. Compound Components
   Где используется:
   • Компонент TaskModal + TaskCard (если модальное окно управляет состоянием карточки)
   Признаки:
   • Родительский компонент (TaskModal) управляет состоянием дочерних (кнопки, таймер)
   • Дети используют общее состояние через контекст
   Обоснование:
   • Гибкость в композиции UI-элементов
   • Сокрытие сложной логики взаимодействия

---

4. Render Props (потенциальное применение)
Где мог бы использоваться:
• Компоненты-обертки для логики таймера/анимаций
Примерная реализация:
tsx
<Timer render={(timeLeft) => (
  <div>{timeLeft}</div>
)}/>
Почему не используется явно:
•	В современных React чаще заменяется на Custom Hooks

---

5. Higher-Order Components (HOC)
   Где используется:
   • Возможно, для защиты роутов (withAuth)
   • Обработка ошибок (withErrorBoundary)
   Пример:
   ts
   export const withAuth = (Component) => {
   return (props) => {
   const { isAuthenticated } = useAuth();
   return isAuthenticated ? <Component {...props} /> : <Redirect to="/login" />;
   };
   };
   Обоснование:
   • Переиспользование логики аутентификации
   • Минимальное дублирование кода

---

Схема архитектуры приложения (упрощенная)
text
src/
│
├── app/ # Next.js App Router
│ ├── (auth) # Public routes
│ ├── (main) # Protected routes
│ └── layout.tsx # Root layout with providers
│
├── features/ # Feature-Sliced Design
│ └── task-management/
│ ├── api.ts # Custom Hooks
│ └── ui/ # Компоненты фичи
│
├── entities/ # Бизнес-сущности
│ ├── task/ # Типы и логика задач
│ └── task-list/ # Типы списков
│
├── shared/ # Общие ресурсы
│ ├── lib/ # Утилиты (localStorage)
│ └── providers/ # Redux/Theme провайдеры
│
└── store/ # Redux Toolkit
├── slices/ # Слайсы состояния
└── store.ts # Конфигурация хранилища
Ключевые связи:

1. Компоненты → Custom Hooks → Redux
2. Роуты → HOC (Auth) → Провайдеры
3. Фичи → Entities → Shared-логика
   Почему выбраны эти паттерны:
4. Provider Pattern + Redux:
   o Централизованное состояние для синхронизации задач между компонентами
   o Интеграция с Next.js SSR
5. Custom Hooks:
   o Изоляция side-эффектов (таймеры, API-запросы)
   o Тестируемость бизнес-логики
6. Compound Components:
   o Единая точка управления сложными UI-состояниями (модалки, формы)
7. HOC (для роутов):
   o Переиспользуемая защита маршрутов без дублирования кода

---

Паттерны, которые не используются и почему:

1. Render Props:
   o Заменен хуками (более читаемая форма)
   o Не требуется динамический рендеринг в текущей логике
2. Singleton:
   o Не нужен, так как Next.js и так гарантирует единый экземпляр хранилища
3. Observer:
   o Redux уже реализует подписку на изменения состояния
   Эта архитектура обеспечивает:
   • Масштабируемость через Feature Slices
   • Тестируемость благодаря изолированным хукам
   • Гибкость UI за счет Compound Components

src/
├── app/ # Маршруты приложения
│ ├── (auth)/ # Группа маршрутов для неавторизованных пользователей
│ │ ├── login/ # Страница входа
│ │ ├── welcome/ # Приветственная страница
│ │ └── layout.tsx # Лейаут для auth-маршрутов
│ ├── (main)/ # Группа маршрутов для авторизованных пользователей
│ │ ├── dashboard/ # Основной дашборд
│ │ ├── tasks/ # Страница задач
│ │ ├── progress/ # Страница прогресса
│ │ ├── comments/ # Страница комментариев
│ │ └── layout.tsx # Лейаут для main-маршрутов
│ ├── layout.tsx # Основной лейаут
│ └── page.tsx # Главная страница
├── entities/ # Бизнес-сущности(задачи, пользователи) с их типами, API и базовой логикой.
│ └── task/ # Сущность задачи
│ └── user/ # Сущность пользователя
├── features/ # Фичи приложения с логикой, компонентами и API.
│ ├── auth/ # Авторизация
│ ├── task-management/ # Управление задачами
│ └── progress-tracking/ # Отслеживание прогресса
├── widgets/ # Виджеты (компоненты, которые собирают фичи в более крупные блоки.)
│ ├── header/ # Хедер
│ ├── sidebar/ # Сайдбар
│ └── task-list/ # Список задач
├── shared/ # Общие компоненты используемые во всем приложении.
│ ├── api/ # API клиент
│ ├── config/ # Конфигурации
│ ├── hooks/ # Кастомные хуки
│ ├── lib/ # Вспомогательные библиотеки
│ ├── providers/ # Провайдеры (Redux, Theme и т.д.)
│ ├── styles/ # Глобальные стили
│ ├── ui/ # UI компоненты (кнопки, инпуты и т.д.)
│ └── utils/ # Вспомогательные утилиты
├── store/ # Redux store
│ ├── slices/ # Слайсы
│ │ ├── authSlice.ts # Слайс авторизации
│ │ └── tasksSlice.ts # Слайс задач
│ └── store.ts # Конфигурация хранилища
└── pages/ # Старые страницы (для совместимости)

# Приложение для управления задачами - Тестовое задание для Middle разработчика

## Технологии для использования:

- Next.js 14+ с App Router
- Управление состоянием: Redux, Redux Toolkit, MobX или любое другое решение для локального управления состоянием на ваш выбор
- **Дополнительный плюс:** Использование внутреннего сервера Next.js для обработки данных (app/api/\*)
- **Дополнительный плюс:** Использование подхода без state manager для управления состоянием, запрещено использовать любой state manager, useState, useReducer, useContext с этим отлично справится что-то другое подумайте что именно и реализуйте

## Архитектурные требования:

- **Обязательно:** Использование методологии Feature-Sliced Design (FSD) для структуры проекта
- **Обязательно:** Применение минимум 3-4 паттернов проектирования в разных частях приложения
- Код должен демонстрировать понимание принципов SOLID и чистой архитектуры
- Код должен быть хорошо структурирован и документирован

## Рекомендуемые паттерны проектирования:

### React-специфичные паттерны:

- **Compound Components**
- **Render Props**
- **Higher-Order Components (HOC)**
- **Custom Hooks**
- **Provider Pattern**

## Функциональность приложения:

### 1. Экран приветствия

- Приветственное сообщение
- Кнопка для перехода к форме авторизации

### 2. Страница авторизации

- Два поля ввода: email и пароль
- Кнопка "Войти"
- Примечание: Можно использовать локальные данные для аутентификации (пожалуйста, предоставьте учетные данные для тестирования)

### 3. Главный экран (Списки задач)

- Отображение списка задач с количеством задач внутри каждого списка
- Пользователь может:
  - Добавить новый список задач
  - Редактировать существующий список задач
  - Удалить список задач (вместе со всеми его задачами)

### 4. Детали списка задач

- Подробный просмотр задач внутри выбранного списка
- Пользователь может:
  - Добавить новую задачу
  - Редактировать задачу
  - Удалить задачу
  - Изменить статус задачи

### 5. Модальное окно с подробной информацией о задаче

- Отображение подробной информации о задаче:

  - Функция редактирования (когда нажата кнопка "Редактировать", поля ввода становятся активными и позволяют редактировать информацию)
  - Кнопка удаления задачи
  - Описание задачи
  - Время, отведенное на задачу
  - Текущий статус
  - время окончания задачи
  - Таймер, показывающий оставшееся время для выполнения задачи - ВРЕМЯ НАЧАНАЕТ ОТСЧЕТ С МОМЕНТА СОЗДАНИЯ!

  - Блок комментариев

## Документация:

В README.md необходимо указать:

- Список использованных паттернов проектирования с обоснованием выбора
- Схему архитектуры приложения
- Описание структуры проекта согласно FSD
- Инструкции по локальному запуску
- Тестовые учетные данные (если используется локальная аутентификация)

## Требования:

1. Использовать Next.js 14+ с App Router для маршрутизации
2. Реализовать управление состоянием с помощью предпочитаемого вами решения
3. Создать чистый, интуитивно понятный интерфейс
4. Обеспечить работу всей функциональности в соответствии с описанием
5. Код должен быть хорошо структурирован и документирован
6. Код должен быть покрыт тестами 20 штук минимум (отдельный плюс за storybook)

## Сдача проекта:

- Предоставить ссылку на GitHub репозиторий с вашим решением
- Предоставить ссылку на deployed app
- Включить инструкции по локальному запуску приложения
- Если используется локальная аутентификация, предоставить тестовые учетные данные в README

## Критерии оценки:

- Качество и организация кода
- Реализация всех требуемых функций
- Правильное использование требуемых технологий
- Учет UI/UX особенностей
- Дополнительные баллы за реализацию функциональности внутреннего сервера Next.js
